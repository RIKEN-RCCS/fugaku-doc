

<!doctype html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5.7. Master-worker type job &#8212; Supercomputer Fugaku User Guide - Use and job execution -  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/bizstyle.css?v=532c1bf3" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=f85107c5" />
    
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/bizstyle.js"></script>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5.8. Environment setting" href="EnvironmentSettings.html" />
    <link rel="prev" title="5.6. Workflow job" href="WorkflowJob.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="EnvironmentSettings.html" title="5.8. Environment setting"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="WorkflowJob.html" title="5.6. Workflow job"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Supercomputer Fugaku User Guide - Use and job execution -  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U"><span class="section-number">5. </span>Job execution</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.7. </span>Master-worker type job</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="master-worker-type-job">
<h1><span class="section-number">5.7. </span>Master-worker type job<a class="headerlink" href="#master-worker-type-job" title="Link to this heading">¶</a></h1>
<p>A master-worker type job is one of the job models with the following characteristics.</p>
<ul>
<li><div class="line-block">
<div class="line">It consists of job script process, master process and worker process.</div>
<div class="line">A master task and a worker process cooperate to execute a calculation task (processing unit of a parallel program).</div>
</div>
</li>
<li><p>The master process supervises the entire calculation task, creates and manages worker processes, and compiles the calculation results.</p></li>
<li><p>The worker process executes the calculation task requested by the master process and returns the result to the master process.</p></li>
<li><p>Even if the compute node assigned to the master-worker type job goes down or the process ends abnormally, the master-worker type job continues as long as the job script process is running.</p></li>
</ul>
<p>Using this feature, users can continue the calculation task by creating a mechanism to re-execute the worker process on another node when the computing node goes down or the worker process ends abnormally.</p>
<figure class="align-default">
<img alt="../_images/MasterWorkerJob_01.png" src="../_images/MasterWorkerJob_01.png" />
</figure>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>The node where the job script process runs is called the “job master node”, and the other nodes are called “job slave nodes”.The purpose of the master process is to manage worker processes that run on job slave nodes, so it must be run on the job master node.</p></li>
<li><p>A similar job model is “bulk job” in that it creates multiple processes. A bulk job is a method in which the same job script is submitted as multiple sub jobs. Each sub job operates independently. For bulk jobs, the number of sub-jobs is specified at job submission and does not change during execution. On the other hand, in the master-worker type job, the master process and each worker process operate while performing inter-process communication as one job. In addition, the worker process is dynamically generated by the master process, so the number changes during job execution.</p></li>
<li><p>For details on master-worker type jobs, see the manual “Job Operation Software End-user’s Guide Master-Worker Type Jobs”.</p></li>
</ul>
</div>
<p>Three methods are supported in terms of how worker processes are generated:</p>
<ul>
<li><div class="line-block">
<div class="line"><a class="reference internal" href="#mswkdynamicprocessgeneration"><span class="std std-ref">Dynamic generation of worker processes</span></a></div>
<div class="line">This method is used when both the master process and the worker process are MPI programs.</div>
<div class="line">The selection of the node that generates the worker process is done by the job operation software.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><a class="reference internal" href="#mswkagentprocess"><span class="std std-ref">Worker process creation request to Agent prosess</span></a></div>
<div class="line">This method is used when the worker process is not an MPI program.</div>
<div class="line">The user controls and manages the generation of worker processes and the selection of nodes that generate them.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><a class="reference internal" href="#mswkpjaexecommand"><span class="std std-ref">pjaexe Worker process generation by pjaexe command</span></a></div>
<div class="line">This method is used when the worker process is not an MPI program.</div>
<div class="line">The user controls and manages the selection of nodes that generate worker processes. However, <strong class="command">pjaexe</strong> command provided by the job operation software is used to generate the worker processes.</div>
</div>
</li>
</ul>
<section id="job-submission">
<h2><span class="section-number">5.7.1. </span>Job Submission<a class="headerlink" href="#job-submission" title="Link to this heading">¶</a></h2>
<p>To submit a job, specify <code class="docutils literal notranslate"><span class="pre">--mswk</span></code> option to <strong class="program">pjsub</strong> command and job script which created on each mounting method.</p>
<blockquote>
<div><p>[Style]</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[_LNlogin]$ </span>pjsub<span class="w"> </span>--mswk<span class="w"> </span>Job<span class="w"> </span>script
</pre></div>
</div>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<ul class="simple">
<li><p>Master-worker type jobs must use torus as the node allocation method.
You can run Master-worker type jobs on any resource group that can specify torus.</p></li>
<li><p>The resource specification (<code class="docutils literal notranslate"><span class="pre">-L</span></code>), node shape and so on must appear as arguments of <strong class="program">pjsub</strong> command or in the job script if necessary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--mswk</span></code> option of <strong class="program">pjsub</strong> command cannot specify just the same as <code class="docutils literal notranslate"><span class="pre">--step</span></code> option, <code class="docutils literal notranslate"><span class="pre">--bulk</span></code> option and <code class="docutils literal notranslate"><span class="pre">--interact</span></code> option</p></li>
<li><p>In the master worker type job, the node that generates the worker process is determined the parallel execution environment of the job operation software, or the user specifies it when generating the process. Thus, there is no meaning on specifying <code class="docutils literal notranslate"><span class="pre">--mpi</span> <span class="pre">rank-map-hostfile</span></code> option of <strong class="program">pjsub</strong> command. If this option is specified, it is ignored.</p></li>
</ul>
</div>
</div></blockquote>
</section>
<section id="dynamic-generation-of-worker-processes">
<span id="mswkdynamicprocessgeneration"></span><h2><span class="section-number">5.7.2. </span>Dynamic generation of worker processes<a class="headerlink" href="#dynamic-generation-of-worker-processes" title="Link to this heading">¶</a></h2>
<p>In the method of dynamically generating the worker process from the master process, the generation of the worker process and communication utilize the mechanism of MPI.
The user must implement the following features:.</p>
<ol class="loweralpha simple">
<li><p>Master program (Master process)</p></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li><p>Generate woker process</p></li>
<li><p>Request execution of worker process</p></li>
<li><p>Confirmation of worker process survival</p></li>
</ol>
</div></blockquote>
<ol class="loweralpha simple" start="2">
<li><p>Worker program (Worker process)</p></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li><p>Receiving computation execution requests from master processes and sending computation results</p></li>
<li><p>Sending calculation completion notification to the master process</p></li>
</ol>
</div></blockquote>
<p>Some MPI functions and MPI subroutines in the MPI program executed in the master-worker type job need to be replaced with those for the master-worker type job.
This is because the job operation software needs to perform processing specific to the master-worker type job.</p>
<p>The following are the names of these MPI functions and MPI subroutines.</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">MPI functions for the master-worker type job (C language)</span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>MPI function name in the normal job</p></th>
<th class="head"><p>MPI function name in the master-worker type job</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MPI_Comm_connect()</p></td>
<td><p>FJMPI_Mswk_connect()</p></td>
</tr>
<tr class="row-odd"><td><p>MPI_Comm_disconnect()</p></td>
<td><p>FJMPI_Mswk_disconnect()</p></td>
</tr>
<tr class="row-even"><td><p>MPI_Comm_accept()</p></td>
<td><p>FJMPI_Mswk_accept()</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above MPI functions for the master-worker type job are declared in the header file <code class="file docutils literal notranslate"><span class="pre">mpi-ext.h</span></code>.</p>
</div>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">MPI subroutines for the master-worker type job (Fortran language)</span><a class="headerlink" href="#id2" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>MPI subroutine name in the normal job</p></th>
<th class="head"><p>MPI subroutine name in the master-worker type job</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MPI_COMM_CONNECT()</p></td>
<td><p>FJMPI_MSWK_CONNECT()</p></td>
</tr>
<tr class="row-odd"><td><p>MPI_COMM_DISCONNECT()</p></td>
<td><p>FJMPI_MSWK_DISCONNECT()</p></td>
</tr>
<tr class="row-even"><td><p>MPI_COMM_ACCEPT()</p></td>
<td><p>FJMPI_MSWK_ACCEPT()</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above MPI subroutines for the master-worker type job are declared in modules <strong class="program">mpi_f08_ext</strong> and <strong class="program">mpi_ext</strong>.
Modules <strong class="program">mpi_f08_ext</strong> and <strong class="program">mpi_ext</strong> correspond to MPI modules <strong class="program">mpi_f08</strong> and <strong class="program">mpi</strong> respectively, so you can quote either in the USE statement.</p>
</div>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>To use the master-worker type job, use the language environment version ‘4.5.0 tcsds-1.2.31’ or later.</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">In this, indicating program example of following image construction.</div>
<div class="line">For details on generating an MPI program, refer to the MPI specifications and MPI User’s Guide.</div>
</div>
<figure class="align-default">
<img alt="../_images/MasterWorkerDynamic_01.png" src="../_images/MasterWorkerDynamic_01.png" />
</figure>
<p>[Master program master_spawn.c]</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mpi.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mpi-ext.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">world_size</span><span class="p">,</span><span class="w"> </span><span class="n">universe_size</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">universe_size_p</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span>
<span class="w">  </span><span class="n">MPI_Status</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>

<span class="w">  </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">worker_comm</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">master_port</span><span class="p">[</span><span class="n">MPI_MAX_PORT_NAME</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">worker_port</span><span class="p">[</span><span class="n">MPI_MAX_PORT_NAME</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Each communicater route rank</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">self_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// SELF (MPI_COMM_SELF)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">master_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// MASTER (MPI_COMM_WORLD)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">worker_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// WORKER (worker_comm)</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Initialization</span>
<span class="w">  </span><span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Get world_size, universe_size</span>
<span class="w">  </span><span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">world_size</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">world_size</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// When there are multiple master processes</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Error! world_size=%d (expected 1)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">world_size</span><span class="p">);</span>
<span class="w">    </span><span class="n">MPI_Abort</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">MPI_Comm_get_attr</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_UNIVERSE_SIZE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">universe_size_p</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flag</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// If Faild to get universe_size</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Error! cannot get universe_size&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">MPI_Abort</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">universe_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">universe_size_p</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;universe_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">universe_size</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">universe_size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// If universe_size is 1</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Error! universe_size=%d (expected &gt; 1)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">universe_size</span><span class="p">);</span>
<span class="w">    </span><span class="n">MPI_Abort</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Open a port for communication with the worker process.</span>
<span class="w">  </span><span class="n">MPI_Open_port</span><span class="p">(</span><span class="n">MPI_INFO_NULL</span><span class="p">,</span><span class="w"> </span><span class="n">master_port</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;master_port=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">master_port</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Generate worker process</span>
<span class="w">  </span><span class="n">MPI_Comm_spawn</span><span class="p">(</span><span class="s">&quot;./worker_spawn.out&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_ARGV_NULL</span><span class="p">,</span><span class="w"> </span><span class="n">universe_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">MPI_INFO_NULL</span><span class="p">,</span><span class="w"> </span><span class="n">self_root</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_SELF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">worker_comm</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_ERRCODES_IGNORE</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Send a port name to worker process</span>
<span class="w">  </span><span class="n">MPI_Send</span><span class="p">(</span><span class="n">master_port</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_MAX_PORT_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">,</span><span class="w"> </span><span class="n">worker_root</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">worker_comm</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Disconnect the connection with woker process</span>
<span class="w">  </span><span class="n">FJMPI_Mswk_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_comm</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Recieve data from worker process (A port name of worker process will be sent)</span>
<span class="w">  </span><span class="n">FJMPI_Mswk_accept</span><span class="p">(</span><span class="n">master_port</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_INFO_NULL</span><span class="p">,</span><span class="w"> </span><span class="n">self_root</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_SELF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">worker_comm</span><span class="p">);</span>
<span class="w">  </span><span class="n">MPI_Recv</span><span class="p">(</span><span class="n">worker_port</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_MAX_PORT_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">,</span><span class="w"> </span><span class="n">worker_root</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">worker_comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;worker_port=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">worker_port</span><span class="p">);</span>
<span class="w">  </span><span class="n">FJMPI_Mswk_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_comm</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Send data to worker process</span>
<span class="w">  </span><span class="n">FJMPI_Mswk_connect</span><span class="p">(</span><span class="n">worker_port</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_INFO_NULL</span><span class="p">,</span><span class="w"> </span><span class="n">self_root</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_SELF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">worker_comm</span><span class="p">);</span>
<span class="w">  </span><span class="n">MPI_Send</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">,</span><span class="w"> </span><span class="n">worker_root</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">worker_comm</span><span class="p">);</span>
<span class="w">  </span><span class="n">FJMPI_Mswk_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_comm</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Closing process</span>
<span class="w">  </span><span class="n">MPI_Close_port</span><span class="p">(</span><span class="n">master_port</span><span class="p">);</span>
<span class="w">  </span><span class="n">MPI_Finalize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[Worker program worker_spawn.c]</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mpi.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mpi-ext.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rank</span><span class="p">;</span>
<span class="w">  </span><span class="n">MPI_Status</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="w">  </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">master_comm</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">master_port</span><span class="p">[</span><span class="n">MPI_MAX_PORT_NAME</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">worker_port</span><span class="p">[</span><span class="n">MPI_MAX_PORT_NAME</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Each communicater route rank</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">self_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// SELF (MPI_COMM_SELF)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">master_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// MASTER (master_comm)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">worker_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// WORKER (MPI_COMM_WORLD)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">message</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Initialize</span>
<span class="w">  </span><span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
<span class="w">  </span><span class="n">MPI_Comm_get_parent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master_comm</span><span class="p">);</span>
<span class="w">  </span><span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rank</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello! rank=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rank</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">worker_root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MPI_Open_port</span><span class="p">(</span><span class="n">MPI_INFO_NULL</span><span class="p">,</span><span class="w"> </span><span class="n">worker_port</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;worker_port=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">worker_port</span><span class="p">);</span><span class="w"> </span><span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">worker_root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// Recieve data from master process</span>
<span class="w">    </span><span class="n">MPI_Recv</span><span class="p">(</span><span class="n">master_port</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_MAX_PORT_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">,</span><span class="w"> </span><span class="n">master_root</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">master_comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;master_port=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">master_port</span><span class="p">);</span><span class="w"> </span><span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Disconnect the connection with master process</span>
<span class="w">  </span><span class="n">FJMPI_Mswk_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master_comm</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Send a port name to master process</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">worker_root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FJMPI_Mswk_connect</span><span class="p">(</span><span class="n">master_port</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_INFO_NULL</span><span class="p">,</span><span class="w"> </span><span class="n">self_root</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_SELF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">master_comm</span><span class="p">);</span>
<span class="w">    </span><span class="n">MPI_Send</span><span class="p">(</span><span class="n">worker_port</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_MAX_PORT_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">,</span><span class="w"> </span><span class="n">master_root</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">master_comm</span><span class="p">);</span>
<span class="w">    </span><span class="n">FJMPI_Mswk_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master_comm</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Recieve data from master process</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">worker_root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FJMPI_Mswk_accept</span><span class="p">(</span><span class="n">worker_port</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_INFO_NULL</span><span class="p">,</span><span class="w"> </span><span class="n">self_root</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_SELF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">master_comm</span><span class="p">);</span>
<span class="w">    </span><span class="n">MPI_Recv</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_MAX_PORT_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">,</span><span class="w"> </span><span class="n">master_root</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">master_comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;message=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">);</span>
<span class="w">    </span><span class="n">FJMPI_Mswk_disconnect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">master_comm</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Closing process</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">worker_root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MPI_Close_port</span><span class="p">(</span><span class="n">worker_port</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">MPI_Finalize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The dynamic worker process generation method requires the <code class="docutils literal notranslate"><span class="pre">--mpi</span> <span class="pre">&quot;shape=1&quot;</span> <span class="pre">--mpi</span> <span class="pre">&quot;proc=1&quot;</span></code> option of the <strong class="program">pjsub</strong> command to be specified so that the master process generated at the start of the MPI program starts only on the job master node.</p>
<p>The following example assigns 385 nodes to a job and 1 node to the master process generated when the MPI program is started.
The remaining 384 nodes are used to dynamically generate worker processes.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[_LNlogin]$ </span>mpifccpx<span class="w"> </span>-o<span class="w"> </span>worker_spawn.out<span class="w"> </span>woker-spawn.c
<span class="gp">[_LNlogin]$ </span>mpifccpx<span class="w"> </span>-o<span class="w"> </span>master-spawn.out<span class="w"> </span>master-spawn.c
<span class="gp">[_LNlogin]$ </span>cat<span class="w"> </span>job_dynamic.sh
<span class="gp">#</span>!/bin/bash<span class="w"> </span>-x
<span class="gp">#</span>PJM<span class="w"> </span>-L<span class="w"> </span><span class="s2">&quot;node=385&quot;</span>
<span class="gp">#</span>PJM<span class="w"> </span>-L<span class="w"> </span><span class="s2">&quot;rscgrp=large&quot;</span>
<span class="gp">#</span>PJM<span class="w"> </span>-L<span class="w"> </span><span class="s2">&quot;elapse=10:00&quot;</span>
<span class="gp">#</span>PJM<span class="w"> </span>--mpi<span class="w"> </span><span class="s2">&quot;shape=1&quot;</span>
<span class="gp">#</span>PJM<span class="w"> </span>--mpi<span class="w"> </span><span class="s2">&quot;proc=1&quot;</span>
<span class="gp">#</span>PJM<span class="w"> </span>-g<span class="w"> </span>groupname
<span class="gp">#</span>PJM<span class="w"> </span>-x<span class="w"> </span><span class="nv">PJM_LLIO_GFSCACHE</span><span class="o">=</span>/vol000N
<span class="gp">#</span>PJM<span class="w"> </span>-s

<span class="go">export PLE_MPI_STD_EMPTYFILE=off</span>
<span class="go">mpiexec -stdout-proc ./output.%j/%/1000r/stdout -stderr-proc ./output.%j/%/1000r/stderr ./master-spawn.out</span>
<span class="gp">[_LNlogin]$ </span>pjsub<span class="w"> </span>--mswk<span class="w"> </span>job_dynamic.sh
</pre></div>
</div>
</section>
<section id="worker-process-creation-request-to-agent-prosess">
<span id="mswkagentprocess"></span><h2><span class="section-number">5.7.3. </span>Worker process creation request to Agent prosess<a class="headerlink" href="#worker-process-creation-request-to-agent-prosess" title="Link to this heading">¶</a></h2>
<p>The method of creating worker processes from the Agent process (hereinafter referred to as Agent process method) is used when the worker process is a non-MPI program.
In the Agent process method, the number of nodes assigned to the job and the number of processes generated by the <strong class="program">mpiexec</strong> command must be same so that only one Agent process is generated on each node.</p>
<p>In this method, the user must implement the following functions for the job:</p>
<ol class="loweralpha simple">
<li><p>Job script</p></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li><p>Execute master program which is master process</p></li>
<li><p>Agent process generation</p></li>
<li><p>Wait for master process termination</p></li>
</ol>
</div></blockquote>
<ol class="loweralpha simple" start="2">
<li><p>Master program (Master process)</p></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li><p>Agent process survival check</p></li>
<li><p>Request worker agent process generation to process</p></li>
</ol>
</div></blockquote>
<ol class="loweralpha simple" start="3">
<li><p>Agent program (Agent Process)</p></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li><p>Establish communication with the master process</p></li>
<li><p>Creating worker processes</p></li>
<li><p>Send processing result of worker process to master process</p></li>
</ol>
</div></blockquote>
<p>Here is an example of the program shown in the figure below.</p>
<figure class="align-default">
<img alt="../_images/MasterWorkerAgent_01.png" src="../_images/MasterWorkerAgent_01.png" />
</figure>
<p>[Job script job_agent.sh]</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#PJM -L &quot;node=385&quot;</span>
<span class="c1">#PJM -L &quot;rscgrp=large&quot;</span>
<span class="c1">#PJM -L &quot;elapse=10:00&quot;</span>
<span class="c1">#PJM --mpi &quot;proc=385&quot;</span>
<span class="c1">#PJM -g groupname</span>
<span class="c1">#PJM -x PJM_LLIO_GFSCACHE=/vol000N</span>

.<span class="w"> </span>utility.sh

<span class="c1"># Create a master process.</span>
./master_agent.out<span class="w"> </span>port_num.txt<span class="w"> </span><span class="p">&amp;</span>
<span class="nv">MASTER_PID</span><span class="o">=</span><span class="nv">$!</span>
<span class="nv">PORT_NUM</span><span class="o">=</span><span class="k">$(</span>cat<span class="w"> </span>port_num.txt<span class="k">)</span>

<span class="c1"># Get the IP address of the job master node (this node).</span>
<span class="nv">IP_ADDR</span><span class="o">=</span><span class="k">$(</span>print_ipaddr<span class="w"> </span><span class="s2">&quot;tofu1&quot;</span><span class="k">)</span>

<span class="c1"># Create an Agent process with the mpiexec command.</span>
mpiexec<span class="w"> </span>start_agent.sh<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">IP_ADDR</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">PORT_NUM</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="p">&amp;</span>
<span class="nb">wait</span><span class="w"> </span><span class="si">${</span><span class="nv">MASTER_PID</span><span class="si">}</span>
</pre></div>
</div>
<p>[Master program master_agent.c]</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/types.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/socket.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">port_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">sockfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(...);</span><span class="w"> </span><span class="c1">// Create a socket.</span>
<span class="w">  </span><span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">        </span><span class="c1">// Bind a socket to a specific port.</span>
<span class="w">  </span><span class="n">listen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">      </span><span class="c1">// Wait for connection from worker process.</span>

<span class="w">  </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">port_file</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;w&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">fprintf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">port_number</span><span class="p">);</span><span class="w"> </span><span class="c1">// Write a port number to file.</span>
<span class="w">  </span><span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">accept</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">    </span><span class="c1">// Accept the connection from woker process.</span>
<span class="w">    </span><span class="p">...</span><span class="w">                     </span><span class="c1">// Request the processing to worker process</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[Agent process start up script start_agent.sh]</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
./agent.out<span class="w"> </span><span class="nv">$@</span>
</pre></div>
</div>
<p>[Agent program agent.c]</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Substitute the IP address and port number of the job master node given in the command line argument.</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ip_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">port_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">my_ip_addr</span><span class="p">;</span>
<span class="w">  </span><span class="n">get_ipaddr</span><span class="p">(</span><span class="s">&quot;tofu1&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_ip_addr</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// If the current node is a job master node (if it has the same IP address as the job master node),</span>
<span class="w">  </span><span class="c1">// terminate the Agent process.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">my_ip_addr</span><span class="p">,</span><span class="w"> </span><span class="n">ip_addr</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Connetc to job master node (use socket connection, etc.)</span>
<span class="w">  </span><span class="n">connect_to</span><span class="p">(</span><span class="n">ip_addr</span><span class="p">,</span><span class="w"> </span><span class="n">port_num</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Proceed depending on job master node if necessary.</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[get_ipaddr()function]</p>
<p>get_ipaddr() function is the function returns the IP address of the local node as a character string.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/types.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/socket.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/ioctl.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;netinet/in.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;net/if.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;arpa/inet.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">get_ipaddr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">device_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">ip_addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ifreq</span><span class="w"> </span><span class="n">ifr</span><span class="p">;</span>

<span class="w">  </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_addr</span><span class="p">.</span><span class="n">sa_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_INET</span><span class="p">;</span>

<span class="w">  </span><span class="n">strncpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span><span class="w"> </span><span class="n">device_name</span><span class="p">,</span><span class="w"> </span><span class="n">IFNAMSIZ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">SIOCGIFADDR</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">ip_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inet_ntoa</span><span class="p">(((</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_in</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_addr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[utility.sh]</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Outputs the IP address of the specified network interface.</span>
<span class="c1"># Usage: print_ipaddr &lt;interface&gt;</span>
print_ipaddr<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span><span class="nb">local</span><span class="w"> </span><span class="nv">INTERFACE</span><span class="o">=</span><span class="nv">$1</span>
<span class="w">  </span><span class="nv">LANG</span><span class="o">=</span>C<span class="w"> </span>ip<span class="w"> </span>addr<span class="w"> </span>show<span class="w"> </span>dev<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">INTERFACE</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>sed<span class="w"> </span>-n<span class="w"> </span><span class="s1">&#39;/.*inet \([0-9.]*\).*/{s//\1/;p}&#39;</span>
<span class="o">}</span>

<span class="c1"># Executes the specified command with a timeout.</span>
<span class="c1"># Usage: timeout &lt;timeout_sec&gt; &lt;command&gt; &lt;arg1&gt; &lt;arg2&gt; ...</span>
timeout<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span><span class="nb">local</span><span class="w"> </span><span class="nv">TIMEOUT</span><span class="o">=</span><span class="nv">$1</span>
<span class="w">  </span><span class="nb">shift</span><span class="w"> </span><span class="m">1</span>

<span class="w">  </span><span class="c1"># Record command execution and process ID</span>
<span class="w">  </span><span class="nb">eval</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">  </span><span class="nb">local</span><span class="w"> </span><span class="nv">PID</span><span class="o">=</span><span class="nv">$!</span>
<span class="w">  </span><span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">PID</span><span class="si">}</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span>true<span class="p">;</span><span class="w"> </span><span class="k">do</span>

<span class="w">    </span><span class="c1"># Check the survival of the command process.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span>!<span class="w"> </span>ps<span class="w"> </span>-p<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">PID</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>&gt;/dev/null<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">      </span><span class="c1"># Get out of loop because process is end.</span>
<span class="w">      </span><span class="k">break</span>
<span class="w">    </span><span class="k">fi</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">TIMEOUT</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>-le<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">      </span><span class="c1"># If time out, end process abnormally.</span>
<span class="w">      </span><span class="nb">kill</span><span class="w"> </span>-KILL<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">PID</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="w">      </span><span class="k">break</span>
<span class="w">    </span><span class="k">fi</span>

<span class="w">    </span><span class="c1"># Back to the head of loop if sleep for 1 second.</span>
<span class="w">    </span>sleep<span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="nv">TIMEOUT</span><span class="o">=</span><span class="k">$((</span><span class="nv">TIMEOUT</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="k">))</span>

<span class="w">  </span><span class="k">done</span>

<span class="w">  </span><span class="c1"># Return process end code.</span>
<span class="w">  </span><span class="nb">wait</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">PID</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">$?</span>
<span class="o">}</span>
</pre></div>
</div>
</section>
<section id="worker-process-generation-by-pjaexe-command">
<span id="mswkpjaexecommand"></span><h2><span class="section-number">5.7.4. </span>Worker process generation by pjaexe command<a class="headerlink" href="#worker-process-generation-by-pjaexe-command" title="Link to this heading">¶</a></h2>
<p>To create worker process, there is a way like using <strong class="program">pjaexe</strong> command offered by job operation software other than creating woker process by Agent process. Use this method for non-MPI programs.</p>
<p>With this method, the user must implement the following features:</p>
<ol class="loweralpha simple">
<li><p>Job script</p></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li><p>Start up worker process by <strong class="program">pjaexe</strong> command</p></li>
</ol>
</div></blockquote>
<ol class="loweralpha simple" start="2">
<li><p>Master program (Master process)</p></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li><p>Confirmation of worker process existence (determined by the presence or absence of connection from worker process)</p></li>
<li><p>Request for task execution to worker process</p></li>
</ol>
</div></blockquote>
<ol class="loweralpha simple" start="3">
<li><p>Woker program (Worker process)</p></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li><p>Establish connection with master process</p></li>
<li><p>Send calculation results to master process</p></li>
</ol>
</div></blockquote>
<p>Here is an example of the program shown in the figure below.</p>
<figure class="align-default">
<img alt="../_images/MasterWorkerPjaexe_01.png" src="../_images/MasterWorkerPjaexe_01.png" />
</figure>
<p>[Job script job_pjaexe.sh]</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#PJM -L &quot;node=385&quot;</span>
<span class="c1">#PJM -L &quot;rscgrp=large&quot;</span>
<span class="c1">#PJM -L &quot;elapse=10:00&quot;</span>
<span class="c1">#PJM -g groupname</span>
<span class="c1">#PJM -x PJM_LLIO_GFSCACHE=/vol000N</span>
<span class="c1"># Execute master process</span>
./master_pjaexe.sh
</pre></div>
</div>
<p>[Master program master_pjaexe.sh]</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
.<span class="w"> </span>utility.sh

<span class="c1"># Get job master node IP address (this node)</span>
<span class="nv">IP_ADDR</span><span class="o">=</span><span class="k">$(</span>print_ipaddr<span class="w"> </span><span class="s2">&quot;tofu1&quot;</span><span class="k">)</span>

<span class="c1"># Initialize the socket to enable acceptiong connection from woker process</span>
<span class="nv">PORT_NUM</span><span class="o">=</span>port<span class="w"> </span>number
...
<span class="c1"># Start up worker process worker.out at all job slave node.</span>
<span class="k">for</span><span class="w"> </span>X<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">$(</span>seq<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">11</span><span class="k">)</span><span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span>Y<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">$(</span>seq<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="m">7</span><span class="k">)</span><span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="nv">VCOORD</span><span class="o">=</span><span class="s2">&quot;(</span><span class="si">${</span><span class="nv">X</span><span class="si">}</span><span class="s2">,</span><span class="si">${</span><span class="nv">Y</span><span class="si">}</span><span class="s2">)&quot;</span>

<span class="w">    </span><span class="c1"># If the pjaexe command does not return within 60 seconds, it will time out.</span>
<span class="w">    </span>timeout<span class="w"> </span><span class="m">60</span><span class="w"> </span>pjaexe<span class="w"> </span>--vcoord<span class="w"> </span><span class="se">\&quot;</span><span class="si">${</span><span class="nv">VCOORD</span><span class="si">}</span><span class="se">\&quot;</span><span class="w"> </span>./worker.out<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">IP_ADDR</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">PORT_NUM</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="w">    </span><span class="nv">RC</span><span class="o">=</span><span class="nv">$?</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">RC</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>-eq<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">      </span><span class="c1"># Close master process abnormally if miss specifying by the user.</span>
<span class="w">      </span><span class="nb">exit</span><span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="k">fi</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">RC</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>-ne<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">      </span><span class="c1"># If pjaexe command closed abnormally, decide as the node is down and add to issued node list.</span>
<span class="w">      </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">VCOORD</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>broken_node_list.txt
<span class="w">    </span><span class="k">fi</span>
<span class="w">  </span><span class="k">done</span>
<span class="k">done</span>

<span class="c1"># Communication with Woker process worker.out and summary processing of calculation results</span>
...&lt;Omitted&gt;<span class="w"> </span>...
<span class="c1"># Close master process</span>
<span class="nb">exit</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Normally, the program that becomes the master process is written in a programming language such as C or Fortran, but here, an example of implementing the master program with a shell script is shown to explain the processing logic. Processing that is difficult to implement with shell scripts (socket initialization processing and communication processing with worker processes) is omitted. For these processes, refer to general means for interprocess communication.</p>
</div>
<p>[utility.sh]</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Output IP address of specified network interface.</span>
<span class="c1"># Usage: print_ipaddr &lt;interface&gt;</span>
print_ipaddr<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span><span class="nb">local</span><span class="w"> </span><span class="nv">INTERFACE</span><span class="o">=</span><span class="nv">$1</span>
<span class="w">  </span><span class="nv">LANG</span><span class="o">=</span>C<span class="w"> </span>ip<span class="w"> </span>addr<span class="w"> </span>show<span class="w"> </span>dev<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">INTERFACE</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>sed<span class="w"> </span>-n<span class="w"> </span><span class="s1">&#39;/.*inet \([0-9.]*\).*/{s//\1/;p}&#39;</span>
<span class="o">}</span>

<span class="c1"># Execute the specified command with time out</span>
<span class="c1"># Usage: timeout &lt;timeout_sec&gt; &lt;command&gt; &lt;arg1&gt; &lt;arg2&gt; ...</span>
timeout<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span><span class="nb">local</span><span class="w"> </span><span class="nv">TIMEOUT</span><span class="o">=</span><span class="nv">$1</span>
<span class="w">  </span><span class="nb">shift</span><span class="w"> </span><span class="m">1</span>

<span class="w">  </span><span class="c1"># Record command execution and process ID</span>
<span class="w">  </span><span class="nb">eval</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">  </span><span class="nb">local</span><span class="w"> </span><span class="nv">PID</span><span class="o">=</span><span class="nv">$!</span>
<span class="w">  </span><span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">PID</span><span class="si">}</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span>true<span class="p">;</span><span class="w"> </span><span class="k">do</span>

<span class="w">    </span><span class="c1"># Check the survival of the command process.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span>!<span class="w"> </span>ps<span class="w"> </span>-p<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">PID</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>&gt;/dev/null<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">      </span><span class="c1"># Get out of loop since process ends.</span>
<span class="w">      </span><span class="k">break</span>
<span class="w">    </span><span class="k">fi</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">TIMEOUT</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>-le<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">      </span><span class="c1"># Close the process abnormally if time out.</span>
<span class="w">      </span><span class="nb">kill</span><span class="w"> </span>-KILL<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">PID</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="w">      </span><span class="k">break</span>
<span class="w">    </span><span class="k">fi</span>

<span class="w">    </span><span class="c1"># Back to the head of loop after sleeping for 1 second.</span>
<span class="w">    </span>sleep<span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="nv">TIMEOUT</span><span class="o">=</span><span class="k">$((</span><span class="nv">TIMEOUT</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="k">))</span>

<span class="w">  </span><span class="k">done</span>

<span class="w">  </span><span class="c1"># Return process end code.</span>
<span class="w">  </span><span class="nb">wait</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">PID</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">$?</span>
<span class="o">}</span>
</pre></div>
</div>
</section>
<section id="notes-on-job-creation">
<h2><span class="section-number">5.7.5. </span>Notes on job creation<a class="headerlink" href="#notes-on-job-creation" title="Link to this heading">¶</a></h2>
<ul>
<li><p>A maximum of 128 pjaexe commands can be executed concurrently in one job.</p>
<ul>
<li><p>If you try to run more than 128, pjaexe terminates abnormally with the following message.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[ERR.] PLE 0050 plexec cannot be executed any further.
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">The pjaexe command can simultaneously generate processes on multiple nodes in a single run by using the –vcoordfile option. Use this command to reduce the number of times the pjaexe command is executed.</div>
<div class="line">[vcoordfile]</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(0)
(1)
(2)
(3)
(4)
</pre></div>
</div>
<p>[command line]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pjaexe --vcoordfile vcoordfile ./worker.out &quot;${IP_ADDR}&quot; &quot;${PORT_NUM}&quot;
</pre></div>
</div>
</li>
</ul>
</li>
<li><div class="line-block">
<div class="line">It is the job creator’s responsibility to create worker processes, detect anomalies, and deal with them.</div>
</div>
</li>
<li><div class="line-block">
<div class="line">In the method of dynamically generating worker processes, if the node on which the worker process is running goes down, all worker processes belonging to the same MPI_COMM_WORLD as the worker process on that node cannot operate. These worker processes remain until the user ends or the job ends.</div>
<div class="line">Also, the node where these worker processes were running is not selected as the worker process regeneration destination until <strong class="command">mpiexec</strong> command ends. However as soon as <strong class="command">mpiexec</strong> command re-executes, note that the down node may be selected again as the worker process destination.</div>
</div>
</li>
<li><p>Note the following when using MPI communication functions in a master-worker type job.</p>
<ul>
<li><p>According to the MPI standard, when MPI communication processing fails, the communication function caller process also terminates abnormally by default. (For example, when the communication destination process ends abnormally during processing or the communication destination node goes down)</p></li>
<li><p>This communication process may be executed not only when the user explicitly calls MPI communication functions such as MPI_Send (), MPI_Recv (), and MPI_Bcast (), but may also be executed by the internal processing of the MPI library. In such a case, it appears to the program that the master process suddenly terminates abnormally while the master process is executing a process unrelated to communication.</p></li>
<li><p>When using the MPI communication function in a master worker type job, take the following actions so that the master process does not end abnormally when the worker process ends abnormally. This reduces the probability of the master process terminating abnormally.</p>
<ol class="arabic">
<li><div class="line-block">
<div class="line">After calling the MPI_Comm_spawn () function, call the FJMPI_Mswk_disconnect () function.</div>
<div class="line">When a process is dynamically created by the MPI_Comm_spawn () function, communication is connected between the created process and the calling process of the MPI_Comm_spawn () function.</div>
<div class="line">MPI’s internal communication processing occurs if this communication is in the connected state and does not occur if disconnected. For this reason, FJMPI_Mswk_disconnect () must be called after calling MPI_Comm_spawn ().</div>
</div>
</li>
<li><div class="line-block">
<div class="line">Call FJMPI_Mswk_connect () or FJMPI_Mswk_accept () before calling the MPI communication function, and call FJMPI_Mswk_disconnect () after calling the MPI communication function.</div>
<div class="line">If the connection destination process has terminated abnormally, the FJMPI_Mswk_connect (), FJMPI_Mswk_accept (), and FJMPI_Mswk_disconnect () functions will only return abnormally and the calling process will not terminate abnormally.</div>
<div class="line">Therefore, it is necessary to call the FJMPI_Mswk_connect () function every time before calling the MPI communication function as shown in the following example. This reduces the impact of worker process errors on the master process.</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>//[Example] When connect from master process to worker process

// Master process
FJMPI_Mswk_connect(worker_port, …, &amp;worker_comm);
MPI_Send(…, worker_comm, …);
FJMPI_Mswk_disconnect(&amp;worker_comm);

// Woker process
FJMPI_Mswk_accept(worker_port, …, &amp;master_comm);
MPI_Recv(…, master_comm, …);
FJMPI_Mswk_disconnect(&amp;master_comm);
</pre></div>
</div>
<p>If the above procedure is not followed, the master process may terminate abnormally at any timing after the worker process terminates abnormally or after the node where the worker process is running goes down. Once master process closed abnormally,  also <strong class="command">mpiexec</strong> command does so too. However, the job script continues to run.</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</section>
<section id="impact-when-system-failure">
<h2><span class="section-number">5.7.6. </span>Impact when system failure<a class="headerlink" href="#impact-when-system-failure" title="Link to this heading">¶</a></h2>
<p>This section describes the effects of an error caused by the system such as a node failure during execution of a master worker type job.</p>
<section id="impact-to-job-work">
<h3><span class="section-number">5.7.6.1. </span>Impact to job work<a class="headerlink" href="#impact-to-job-work" title="Link to this heading">¶</a></h3>
<p>Depending on the nature of the error, the master-worker type job may end or continue.</p>
<ul>
<li><p>The case that master worker type job closes</p>
<p>In the following cases, as with other job models, the master worker type job ends and is requeued.</p>
<ul class="simple">
<li><p>When a job master node is down</p></li>
<li><p>When an ICC or Port failure occurs on a compute node assigned to a master worker type job</p></li>
<li><p>When the administrator (cluster administrator) specifies to terminate the job immediately when the node assigned to the master worker type job is disconnected from operation</p></li>
<li><p>When the BIO/SIO/GIO allocated by the job using the shared temporary area or the cache area of the second-layer storage goes down</p></li>
</ul>
</li>
<li><div class="line-block">
<div class="line">The case that master worker type job continues</div>
</div>
<p>In the following cases, the master worker type job continues. However, if a worker process becomes abnormal due to these reasons, it is necessary to consider measures such as executing the worker process on another node in the user program.</p>
<ul class="simple">
<li><p>Service error of job operation software on job slave node</p></li>
<li><p>Job slave node down</p></li>
<li><p>Hadware (CPU or memory) error on job slave node</p></li>
</ul>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>If the cause of job termination is on the user side (ex: resource limit values such as CPU time exceeded), whether or not the job is requeued is specified at the time of job submission and job ACL, as with other job models. It depends on the function setting.</p>
</div>
</section>
<section id="impact-on-job-statistics">
<h3><span class="section-number">5.7.6.2. </span>Impact on job statistics<a class="headerlink" href="#impact-on-job-statistics" title="Link to this heading">¶</a></h3>
<p>If a node failure occurs during execution of a master worker type job, the job statistics output by <strong class="program">pjsub -s/-S</strong> and <strong class="program">pjstat -v</strong> are as follows.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="line-block">
<div class="line">PC、PJM CODE</div>
<div class="line">(End job code)</div>
</div>
</td>
<td><p>If a master-worker type job ends abnormally due to a job master node going down or Fugaku failure (ICC error), the job completion code in the job statistics will be the same as that for a normal job. If the error does not affect the continuation of the master-worker type job, such as when only the job slave node is down, the master-worker type job is executed to the end. If closed with no error, end job code is 0.</p></td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">REASON</div>
<div class="line">(The closing reason)</div>
</div>
</td>
<td><p>Since this is the same as end code, if job closed with no error, it will be “-“.</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">name (REQUIRE)</div>
<div class="line">(The amount of requred material)</div>
</div>
</td>
<td><p>Items with “(REQUIRE)” such as “NODE NUM (REQUIRE)” are the values specified by the user when the job is submitted, regardless of whether the node is down.</p></td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">name (ALLOC)</div>
<div class="line">(The amount of assignning material)</div>
</div>
</td>
<td><p>Items with “(ALLOC)” such as “NODE NUM (ALLOC)” are the values determined when the job is submitted, regardless of whether the node is down.</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">name (USE)</div>
<div class="line">(The amount of used material)</div>
</div>
</td>
<td><p>Items with “(USE)” such as “NODE NUM (USE)” are excluded values for the failed node.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="impact-to-command-displyaing">
<h3><span class="section-number">5.7.6.3. </span>Impact to command displyaing<a class="headerlink" href="#impact-to-command-displyaing" title="Link to this heading">¶</a></h3>
<p><strong class="program">pjshowrsc</strong> command, offered by job operation software, can display the number of nodes as computer resources.</p>
<p>If a node assigned to a master worker type job goes down during job execution, the down node is excluded from available resources.</p>
<ul class="simple">
<li><p>Without argument</p></li>
</ul>
<blockquote>
<div><p>The TOTAL and ALLOC values are reduced by the number of nodes that are down.</p>
<p>[Before job slave node is down]</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[_LNlogin]$ </span>pjshowrsc
<span class="go">[ CLST: fugaku-comp ]</span>
<span class="go">RSCUNIT          NODE</span>
<span class="go">                 TOTAL   FREE  ALLOC</span>
<span class="go">rscunit_ft01    158976  94269  64707</span>
</pre></div>
</div>
<p>[After 1 node of job slave node is down]</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[_LNlogin]$ </span>pjshowrsc
<span class="go">[ CLST: fugaku-comp ]</span>
<span class="go">RSCUNIT          NODE</span>
<span class="go">                 TOTAL   FREE  ALLOC</span>
<span class="go">rscunit_ft01    158975  94269  64706</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li><p>When specified  <code class="docutils literal notranslate"><span class="pre">-l</span></code> option</p></li>
</ul>
<blockquote>
<div><p>The TOTAL and ALLOC values for each resource are reduced by the number of nodes that are down.</p>
<p>[Before job slave node is down]</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[_LNlogin]$ </span>pjshowrsc<span class="w"> </span>-l
<span class="go">[ CLST: fugaku-comp ]</span>
<span class="go">[ RSCUNIT: rscunit_ft01 ]</span>
<span class="go">     RSC    TOTAL    FREE   ALLOC</span>
<span class="go">    node   158976   75231   83745</span>
<span class="go">     cpu  7630848 3611088 4019760</span>
<span class="go">     mem    4.4Pi   4.4Pi   672Gi</span>
</pre></div>
</div>
<p>[After 1 node of job slave node is down]</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[_LNlogin]$ </span>pjshowrsc<span class="w"> </span>-l
<span class="go">[ CLST: fugaku-comp ]</span>
<span class="go">[ RSCUNIT: rscunit_ft01 ]</span>
<span class="go">     RSC    TOTAL    FREE   ALLOC</span>
<span class="go">    node   158975   75231   83744</span>
<span class="go">     cpu  7630800 3611088 4019712</span>
<span class="go">     mem    4.4Pi   4.4Pi   672Gi</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">5.7. Master-worker type job</a><ul>
<li><a class="reference internal" href="#job-submission">5.7.1. Job Submission</a></li>
<li><a class="reference internal" href="#dynamic-generation-of-worker-processes">5.7.2. Dynamic generation of worker processes</a></li>
<li><a class="reference internal" href="#worker-process-creation-request-to-agent-prosess">5.7.3. Worker process creation request to Agent prosess</a></li>
<li><a class="reference internal" href="#worker-process-generation-by-pjaexe-command">5.7.4. Worker process generation by pjaexe command</a></li>
<li><a class="reference internal" href="#notes-on-job-creation">5.7.5. Notes on job creation</a></li>
<li><a class="reference internal" href="#impact-when-system-failure">5.7.6. Impact when system failure</a><ul>
<li><a class="reference internal" href="#impact-to-job-work">5.7.6.1. Impact to job work</a></li>
<li><a class="reference internal" href="#impact-on-job-statistics">5.7.6.2. Impact on job statistics</a></li>
<li><a class="reference internal" href="#impact-to-command-displyaing">5.7.6.3. Impact to command displyaing</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="WorkflowJob.html"
                          title="previous chapter"><span class="section-number">5.6. </span>Workflow job</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="EnvironmentSettings.html"
                          title="next chapter"><span class="section-number">5.8. </span>Environment setting</a></p>
  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="EnvironmentSettings.html" title="5.8. Environment setting"
             >next</a></li>
        <li class="right" >
          <a href="WorkflowJob.html" title="5.6. Workflow job"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Supercomputer Fugaku User Guide - Use and job execution -  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" ><span class="section-number">5. </span>Job execution</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.7. </span>Master-worker type job</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2025, RIKEN Center for Computational Science.
    &nbsp;&nbsp;<a href="https://www.fugaku.r-ccs.riken.jp/en/">Fugaku website Top</a>
    </div>
  </body>
</html>